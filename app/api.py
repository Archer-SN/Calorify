"""
This file will handle the logic of communicating with API such as EDAMAM, ChatGPT, etc.
"""

from .scripts import credentials
from .models import *

import openai
import json
import requests

openai.api_key = credentials.OPEN_AI_KEY

GPT_MODEL = "gpt-3.5-turbo"

# Id and Keys for the food database api
EDAMAM_FOOD_DB_ID = "35db61c2"
EDAMAM_FOOD_DB_KEY = credentials.EDAMAM_FOOD_DB_KEY

# AP stands for Access Point
# The parser access point handles text search for foods as well as filters for the foods like presence specific nutrient content or exclusion of allergens.
PARSER_AP = "https://api.edamam.com/api/food-database/v2/parser?app_id={app_id}&app_key={app_key}".format(
    app_id=EDAMAM_FOOD_DB_ID, app_key=EDAMAM_FOOD_DB_KEY)

# In the response to your parser request you receive the a food ID for each database match.
# Using the food ID and the measure URI, which parser provides, you can make a request to the nutrients access point.
# The nutrients access points returns nutrition with diet and health labels for a given quantity of the food.
NUTRIENTS_AP = "https://api.edamam.com/api/food-database/v2/nutrients?app_id={app_id}&app_key={app_key}".format(
    app_id=EDAMAM_FOOD_DB_ID, app_key=EDAMAM_FOOD_DB_KEY)

# Id and keys for the recipe database api
EDAMAM_RECIPE_DB_ID = "c03ec76f"
EDAMAM_RECIPE_DB_KEY = credentials.EDAMAM_RECIPE_DB_KEY

# Id and keys for the nutrients analysis api
EDAMAM_NUTRIENTS_ANALYSIS_ID = "8f60cfad"
EDAMAM_NUTRIENTS_ANALYSIS_KEY = credentials.EDAMAM_NUTRIENTS_ANALYSIS_KEY

STANDARD_MEASURE_UNIT = "g"
STANDARD_MEASURE_URI = "http://www.edamam.com/ontologies/edamam.owl#Measure_gram"
STANDARD_MEASURE_QUANTITY = 100


# I'm not sure whether this should be put in views.py

# Add the given food to the database if it does not yet exist
# food_name is a string that has the format "{amount} {unit} {food}"
# We'll call the database with the food weight of 100 grams (A standard weight for storing in the database)
# Return a tuple that contains the Food created and its weight
def analyze_food(food_name):
    parser_params = {"ingr": food_name}
    # Calls the database api to obtain list of foods
    parser_request = requests.get(PARSER_AP, params=parser_params).json()
    # Gets the first food that is returned from the API call
    data = parser_request["parsed"][0]
    food_data = data["food"]
    category, category_created = FoodCategory.objects.get_or_create(description=food_data["category"])
    food, food_created = Food.objects.get_or_create(food_id=food_data["foodId"], label=food_data["label"],
                                                    food_category=category)
    if not food_created:
        # We are going to use 100g as a standard quantity for storing food in the database
        ingredients = {
            "ingredients": [
                {
                    "quantity": STANDARD_MEASURE_QUANTITY,
                    "measureURI": STANDARD_MEASURE_URI,
                    "foodId": food_data["foodId"]
                }
            ]
        }
        # Gets the nutrition data
        nutrition_request = requests.post(NUTRIENTS_AP, json=ingredients).json()
        # Adds each nutrient to the database
        for ntr_code, nutrient_data in nutrition_request["totalNutrients"].items():
            nutrient, nutrient_created = Nutrient.objects.get_or_create(ntr_code=ntr_code, label=nutrient_data["label"],
                                                                        unit_name=nutrient_data["unit"])
            food_nutrient = FoodNutrient.objects.create(food=food, nutrient=nutrient, amount=nutrient_data["quantity"])

    return food, data["quantity"] * data["measure"]["weight"]


# Analyze each food generated by chatGPT and import each food to the database (Caching the food)
# foods is a list of strings of food that has the format "{amount} {unit} {food}"
def analyze_meal_plan(food_list):
    analyzed_food_list = []
    for food_name in food_list:
        analyzed_food = analyze_food(food_name)
        analyzed_food_list.append(analyze_food)
    return analyzed_food_list


def import_food(user, food_name):
    food, weight = analyze_food(food_name)
    user_food = UserFood.objects.create(food=food)
    daily_entry, created = DailyEntry.objects.get_or_create(user=user)
    # Actually create the UserFood object so that we can get the real total nutrients
    user_food = UserFood.objects.create(food=food, daily_entry=daily_entry, weight=weight)


def import_routine_plan():
    pass


# Ask ChatGPT for a meal plan given the user's information
def ask_meal_plan_gpt(user):
    messages = [
        # {
        #     "role": "system",
        #     "content": "Assistant is an intelligent chatbot designed to help users answer health and fitness related questions."
        # },
        {"role": "user",
         "content": "Generate a healthy and tasty meal plan that has a total of {tdee} calories.".format(
             tdee=user.get_tdee())}]
    functions = [{
        "name": "analyze_meal_plan",
        "description": "Call the food database to obtain food nutrients",
        "parameters": {
            "type": "object",
            "properties": {
                "food_list": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "food_name": {"type": "string"},
                            "food_portion": {"type": "string"}
                        }
                    },
                    "description": "A list of foods.",
                }
            },
            "required": ["food_list"],
        },
    }]
    response = openai.ChatCompletion.create(
        model=GPT_MODEL,
        messages=messages,
        functions=functions,
        temperature=1,
        max_tokens=512,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        function_call={"name": "analyze_meal_plan"}
    )
    response_message = response["choices"][0]["message"]
    print(response_message)
    # Check if GPT wanted to call a function
    if response_message.get("function_call"):
        # Call the function
        # Note: the JSON response may not always be valid; be sure to handle errors
        available_functions = {
            "analyze_meal_plan": analyze_meal_plan,
        }  # only one function in this example, but you can have multiple
        function_name = response_message["function_call"]["name"]

        function_to_call = available_functions[function_name]
        function_args = json.loads(response_message["function_call"]["arguments"])
        function_response = function_to_call(food_list=function_args.get("food_list"))
        print(function_response)
        print("function called")

    print("Hello")
    return